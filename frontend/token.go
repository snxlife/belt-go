package frontend

import (
	"belt/reporter"
	"belt/utils"
	"fmt"
	"strconv"
	"strings"
)

type TokenType int

type Token struct {
	ttype TokenType
	value string
	where reporter.Where
}

const (
	EoF TokenType = iota

	Ident     		// ðŸŽ€ ([_a-zA-Z][_a-zA-Z0-9]*)
	
	LlInt     		// ðŸŽ€ ([0-9]+)
    LlFloat   		// ðŸŽ€ ([0-9]+\.[0-9]*)
	LlString  		// ðŸŽ€ "(.*)"
	LlBool    		// ðŸŽ€ (true)|(false)
	LlNil     		// ðŸŽ€ nil
	
	KFn       		// ðŸŽ€ fn
	KIf       		// ðŸŽ€ if
	KElse     		// ðŸŽ€ else
	KWhile    		// ðŸŽ€ while
	KFor      		// ðŸŽ€ for
	KIn       		// ðŸŽ€ in
	KLet      		// ðŸŽ€ let
	KBreak    		// ðŸŽ€ break
	KContinue 		// ðŸŽ€ continue
	KReturn   		// ðŸŽ€ return
	KStruct   		// ðŸŽ€ struct
	KEnum     		// ðŸŽ€ enum
	KImpl     		// ðŸŽ€ impl
	
	KTInt     		// ðŸŽ€ int
	KTFloat   		// ðŸŽ€ float
	KTString  		// ðŸŽ€ string
	KTBool    		// ðŸŽ€ bool
	KTVar     		// ðŸŽ€ '<Ident>
	
	OAdd      		// ðŸŽ€ +
	OAddf     		// ðŸŽ€ +.
	OConnect  		// ðŸŽ€ ++
	OSub      		// ðŸŽ€ -
	OSubf     		// ðŸŽ€ -.
	OMul      		// ðŸŽ€ *
	OMulf     		// ðŸŽ€ *.
	ODiv      		// ðŸŽ€ /
	ODivf     		// ðŸŽ€ /.
	OEq       		// ðŸŽ€ ==
	ONeq	  		// ðŸŽ€ !=
	OGrt      		// ðŸŽ€ >
	OGeq      		// ðŸŽ€ >=
	OLes      		// ðŸŽ€ <
	OLeq      		// ðŸŽ€ <=
	OAnd      		// ðŸŽ€ &&
	OOr       		// ðŸŽ€ ||
	OBXor     		// ðŸŽ€ ^
	OBAnd     		// ðŸŽ€ &
	OBOr      		// ðŸŽ€ |
	ONot      		// ðŸŽ€ !
	OBNot     		// ðŸŽ€ ~
	OMovl     		// ðŸŽ€ <<
	OMovr     		// ðŸŽ€ >>
	OMember   		// ðŸŽ€ .
	OLookup   		// ðŸŽ€ ::
	OAssign   		// ðŸŽ€ =
	
	Colon     		// ðŸŽ€ :
	Comma     		// ðŸŽ€ ,
	Semi      		// ðŸŽ€ ;
	ThinArr   		// ðŸŽ€ ->
	FatArr    		// ðŸŽ€ =>
	
	LBrace    		// ðŸŽ€ (
	RBrace    		// ðŸŽ€ )
	LBracket  		// ðŸŽ€ [
	RBracket  		// ðŸŽ€ ]
	LBra        	// ðŸŽ€ {
	RBra        	// ðŸŽ€ }
		
	BSCorePrint 	// ðŸŽ€ __core_print
)

var TokenStringMap = map[TokenType]string{
	EoF:      		"eof",
	Ident:    		"identifier",
	LlInt:    		"literal integer",
	LlFloat:  		"literal float",
	LlString: 		"literal string",
	LlBool:   		"literal boolean",
	LlNil:    		"literal nil",
	KFn:      		"keyword fn",
	KIf:      		"keyword if",
	KElse:    		"keyword else",
	KWhile:   		"keyword while",
	KFor:     		"keyword for",
	KIn:      		"keyword in",
	KLet:     		"keyword let",
	KBreak:   		"keyword break",
	KContinue: 		"keyword continue",
	KReturn: 		"keyword return",
	KStruct: 		"keyword struct",
	KEnum:	 		"keyword enum",
	KImpl:	 		"keyword impl",
	KTInt: 			"type `int`",
	KTFloat: 		"type `float`",
	KTString: 		"type `string`",
	KTBool: 		"type `bool`",
	KTVar: 			"type variable",
	OAdd: 			"operator +",
	OAddf: 			"operator +.",
	OConnect: 		"operator ++",
	OSub: 			"operator -",
	OSubf: 			"operator -.",
	OMul: 			"operator *",
	OMulf: 			"operator *.",
	ODiv: 			"operator /",
	ODivf: 			"operator /.",
	OEq: 			"operator ==",
	ONeq: 			"operator !=",
	OGrt: 			"operator >",
	OGeq: 			"operator >=",
	OLes: 			"operator <",
	OLeq: 			"operator <=",
	OAnd: 			"operator &&",
	OOr: 			"operator ||",
	OBXor: 			"operator ^",
	OBAnd: 			"operator &",
	OBOr: 			"operator |",
	ONot: 			"operator !",
	OBNot: 			"operator ~",
	OMovl: 			"operator <<",
	OMovr: 			"operator >>",
	OMember: 		"operator .",
	OLookup: 		"operator ::",
	OAssign: 		"operator =",
	Colon: 			"colon",
	Comma: 			"comma",
	Semi: 			"semi",
	ThinArr: 		"thin arrow",
	FatArr: 		"fat arrow",
	LBrace: 		"left brace",
	RBrace: 		"right brace",
	LBracket: 		"left square bracket",
	RBracket: 		"right square bracket",
	LBra: 			"left bracket",
	RBra: 			"right bracket",
	BSCorePrint:	"builtin name `__core_print`",
}

func (tt *TokenType) ToString() string {
	return TokenStringMap[*tt]
}

func (t *Token) AsInt(file *utils.File) int {
	i, err := strconv.ParseInt(t.value, 10, 0)
	if err != nil {
		err := reporter.Error(
			t.where,
			fmt.Sprintf("cannot convert `%v` into a int value", t.value),
		)
		reporter.Report(&err, file)
	}
	return int(i)
}

func (t *Token) AsFloat(file *utils.File) float64 {
	i, err := strconv.ParseFloat(t.value, 64)
	if err != nil {
		err := reporter.Error(
			t.where,
			fmt.Sprintf("cannot convert `%v` into a float value", t.value),
		)
		reporter.Report(&err, file)
	}
	return float64(i)
}

func (t *Token) AsBool(file *utils.File) bool {
	if t.value == "true" {
		return true
	} else if t.value == "false" {
		return false
	}
	err := reporter.Error(
		t.where,
		fmt.Sprintf("cannot convert `%v` into a boolean value", t.value),
	)
	reporter.Report(&err, file)
	return false
}

func (t *Token) AssertType(tt TokenType) bool {
	return t.ttype == tt
}

func (t *Token) Where() reporter.Where {
	return t.where
}

type TokenStream struct {
	tokens []Token
	curr uint
}

func (ts *TokenStream) Next() *Token {
	res := &ts.tokens[ts.curr]
	ts.curr += 1
	return res
}

func (ts *TokenStream) Peek() *Token {
	res := &ts.tokens[ts.curr]
	return res
}

func (ts *TokenStream) Forward() {
	ts.curr += 1;
}

func (ts *TokenStream) Backward() {
	ts.curr -= 1;
}

func (ts *TokenStream) IsEof() bool {
	return ts.Peek().ttype == EoF
}

func (ts *TokenStream) AssertNext(tt TokenType) *Token {
	tok := ts.Peek()
	if tok.ttype == tt {
		ts.Forward()
		return tok
	}
	return nil
}

func (ts *TokenStream) AssertNextOrReport(tt TokenType, file *utils.File) *Token {
	tok := ts.Peek()
	if tok.ttype == tt {
		ts.Forward()
		return tok
	}
	err := reporter.Error(
		tok.where,
		fmt.Sprintf("expected %v, found %v", tt.ToString(), tok.ttype.ToString()),
	)
	reporter.Report(&err, file)
	utils.Exit(1)
	panic("reaching an unreachable code! something went wrong") // unreachable
}

func (ts *TokenStream) ToString() string {
	res := make([]string, 0)
	for _, tok := range(ts.tokens) {
		switch tok.ttype {
		case LlString:
			res = append(res, fmt.Sprintf("\"%v\"", tok.value))
		default:
			res = append(res, tok.value)
		}
	}
	return strings.Join(res, " ")
}